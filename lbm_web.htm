<!DOCTYPE html>
<!-- saved from url=(0082)https://mchouza.googlecode.com/svn/trunk/webgl-proc/lb-fluid-sim/lb_fluid_sim.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<script id="shader-fs-utils" type="x-shader/x-fragment">
precision highp float;
precision highp int;

const float OMEGA = 1.9;
const float Nx = 1024.0;
const float Ny = 128.0;
const float PI = 3.1415926535897932384626433832795;
const float VEL = 0.1;

const float RHO_SCALE = 2.0;
const float U_SCALE = 2.0;
const float U_BIAS = 1.0;

const float BL = 100.0/1024.0;
const float BR = 356.0/1024.0;
const float BT = 48.0/128.0;
const float BB = 80.0/128.0;


// The numbers are encoded using 3 component of a color (RGB). When storing
// 'x' in a component, the persisted value is 'round(x * 255.0) % 256' and 
// the recovered value is obtained doing a floating point division by 255.
// The encoding is a fixed point one, going from 0.000000 to 0.ffffff and 
// storing each pair of hexadecimal digits in a color component.

vec4 float2Color(float f)
{
    f *= 256.0;
    float r = floor(f);
    f -= r;
    f *= 256.0;
    float g = floor(f);
    f -= g;
    f *= 256.0;
    float b = floor(f);
    return vec4(r / 255.0, g / 255.0, b / 255.0, 1.0);
}

float color2Float(vec4 c)
{
    return c.r * 255.0 / 256.0 + c.g * 255.0 / (256.0 * 256.0) + c.b * 255.0 / (256.0 * 256.0 * 256.0);
}

float getFEq(float rho, vec2 u, int i)
{
    float dotProd = 0.0;
    if ((i == 1) || (i == 2) || (i == 8))
        dotProd += u.x;
    else if ((i >= 4) && (i <= 6))
        dotProd -= u.x;
    if ((i >= 2) && (i <= 4))
        dotProd += u.y;
    else if (i >= 6)
        dotProd -= u.y;
    float scD;
    if (i == 0)
        scD = 4.0 / 9.0;
    else
        scD = 1.0 / (36.0 - 27.0 * mod(float(i), 2.0));
    return scD * rho * (1.0 + 3.0 * dotProd + 4.5 * dotProd * dotProd - 1.5 * dot(u, u));
}

vec4 rho2Color(float rho)
{
    return float2Color(rho / RHO_SCALE);
}

float color2Rho(vec4 c)
{
    return color2Float(c) * RHO_SCALE;
}

vec4 u2Color(float u)
{
    return float2Color((u + U_BIAS) / U_SCALE);
}

float color2U(vec4 c)
{
    return color2Float(c) * U_SCALE - U_BIAS;
}

float triangleArea(vec2 p1, vec2 p2, vec2 p3) 
{
			return (p3.x*p2.y-p2.x*p3.y)-(p3.x*p1.y-p1.x*p3.y)+(p2.x*p1.y-p1.x*p2.y);
}
</script>
<script id="shader-fs-init-f" type="x-shader/x-fragment">
precision highp float;
precision highp int;

uniform int uI;
uniform highp sampler2D uSampler0, uSampler1, uSampler2;

varying vec2 vTextureCoord;

void main(void)
{
    float rho = color2Rho(texture2D(uSampler0, vTextureCoord));
    float ux = color2U(texture2D(uSampler1, vTextureCoord));
    float uy = color2U(texture2D(uSampler2, vTextureCoord));
    
    float fEq = getFEq(rho, vec2(ux, uy), uI);

    gl_FragColor = float2Color(fEq);
}
</script>
<script id="shader-fs-init-display" type="x-shader/x-fragment">
precision highp float;
precision highp int;

varying vec2 vTextureCoord;

void main(void)
{
    float r = sin(12.0 * PI * vTextureCoord.x);
    float g = sin(12.0 * PI * vTextureCoord.x + 2.0 / 3.0 * PI);
    float b = sin(12.0 * PI * vTextureCoord.x + 4.0 / 3.0 * PI);

    gl_FragColor = vec4(r, g, b, 1.0);
}
</script>
<script id="shader-fs-update-f" type="x-shader/x-fragment">
precision highp float;
precision highp int;

uniform highp sampler2D uSampler0, uSampler1, uSampler2, uSampler3, uSampler4, uSampler5;
uniform int uI;
uniform float uVel;
uniform float uOmega;

varying vec2 vTextureCoord;

void main(void)
{
    vec2 offset = vec2(0.0, 0.0);
    
    if ((uI == 1) || (uI == 2) || (uI == 8))
        offset.x = -1.0 / Nx;
    else if ((uI >= 4) && (uI <= 6))
        offset.x = 1.0 / Nx;
    if ((uI >= 2) && (uI <= 4))
        offset.y = -1.0 / Ny;
    else if (uI >= 6)
        offset.y = 1.0 / Ny;

    float rho = color2Rho(texture2D(uSampler0, vTextureCoord + offset));
    float ux = color2U(texture2D(uSampler1, vTextureCoord + offset));
    float uy = color2U(texture2D(uSampler2, vTextureCoord + offset));
    float f = color2Float(texture2D(uSampler3, vTextureCoord + offset)) * (1.0 - uOmega) +
        getFEq(rho, vec2(ux, uy), uI) * uOmega;
    float obst = texture2D(uSampler4, vTextureCoord + offset).r;

    //if (vTextureCoord.x < 0.01 || vTextureCoord.y<0.01 || vTextureCoord.y>0.99)
    if (vTextureCoord.x < 1.0/Nx)
        f = getFEq(1.0, vec2(uVel, 0.0), uI);
    if (obst != 0.0)
        f = getFEq(rho, vec2(0.0, 0.0), uI);
        
    gl_FragColor = float2Color(f);
}
</script>
<script id="shader-fs-update-f-all" type="x-shader/x-fragment">
precision highp float;
precision highp int;

uniform highp sampler2D uSampler0, uSampler1, uSampler2, uSampler3, uSampler4, uSampler5, uSampler6, uSampler5, uSampler8, uSampler9, uSampler10, uSampler11;

varying vec2 vTextureCoord;

void main(void)
{
    float f[9],f_tmp[9];
    vec2 offset = vec2(0.0, 0.0);
    vec2 offset2 = vec2(0.0, 0.0);

    float obst = texture2D(uSampler4, vTextureCoord + offset).r;
    float rho = color2Rho(texture2D(uSampler0, vTextureCoord + offset));
    float ux = color2U(texture2D(uSampler1, vTextureCoord + offset));
    float uy = color2U(texture2D(uSampler2, vTextureCoord + offset));
    uI = 0;
    float f[0] = color2Float(texture2D(uSampler3, vTextureCoord + offset)) * (1.0 - OMEGA) +
        getFEq(rho, vec2(ux, uy), uI) * OMEGA;
    uI = 1;
    offset.x = -1.0 / Nx;
    offset.y = 0.0;
    float f[1] = color2Float(texture2D(uSampler4, vTextureCoord + offset)) * (1.0 - OMEGA) +
        getFEq(rho, vec2(ux, uy), uI) * OMEGA;
    uI = 2;
    offset.x = -1.0 / Nx;
    offset.y = -1.0 / Ny;
    float f[2] = color2Float(texture2D(uSampler4, vTextureCoord + offset)) * (1.0 - OMEGA) +
        getFEq(rho, vec2(ux, uy), uI) * OMEGA;
    uI = 3;
    offset.x = 0.0;
    offset.y = -1.0 / Ny;
    float f[3] = color2Float(texture2D(uSampler4, vTextureCoord + offset)) * (1.0 - OMEGA) +
        getFEq(rho, vec2(ux, uy), uI) * OMEGA;
    uI = 4;
    offset.x = 1.0 / Nx;
    offset.y = -1.0 / Ny;
    float f[4] = color2Float(texture2D(uSampler4, vTextureCoord + offset)) * (1.0 - OMEGA) +
        getFEq(rho, vec2(ux, uy), uI) * OMEGA;
    uI = 5;
    offset.x = 1.0 / Nx;
    offset.y = 0.0;
    float f[5] = color2Float(texture2D(uSampler4, vTextureCoord + offset)) * (1.0 - OMEGA) +
        getFEq(rho, vec2(ux, uy), uI) * OMEGA;
    uI = 6;
    offset.x = 1.0 / Nx;
    offset.y = 1.0 / Ny;
    float f[6] = color2Float(texture2D(uSampler4, vTextureCoord + offset)) * (1.0 - OMEGA) +
        getFEq(rho, vec2(ux, uy), uI) * OMEGA;
    uI = 7;
    offset.x = 0.0;
    offset.y = 1.0 / Ny;
    float f[7] = color2Float(texture2D(uSampler4, vTextureCoord + offset)) * (1.0 - OMEGA) +
        getFEq(rho, vec2(ux, uy), uI) * OMEGA;
    uI = 8;
    offset.x = -1.0 / Nx;
    offset.y = 1.0 / Ny;
    float f[8] = color2Float(texture2D(uSampler4, vTextureCoord + offset)) * (1.0 - OMEGA) +
        getFEq(rho, vec2(ux, uy), uI) * OMEGA;
    
    
    //float f_opp = color2Float(texture2D(uSampler5, vTextureCoord - offset));
    

    if (vTextureCoord.x < 0.01)
    for(int i =0;i<9;i++){
        f[i] = getFEq(1.0, vec2(VEL, 0.0), i);
        }
    if (obst != 0.0)
    for(int i =0;i<9;i++){
        f[i] = getFEq(1.0, vec2(0.0, 0.0), i);
        }
        //f = f_opp;
        
    gl_FragColor = float2Color(f);
}
</script>
<script id="shader-fs-update-obst-circle" type="x-shader/x-fragment">
precision highp float;
precision highp int;

uniform highp sampler2D uSampler0;
uniform float uPointX, uPointY;
uniform int uClear;
uniform int uAdd;
uniform float uRadius;

varying vec2 vTextureCoord;

void main(void)
{
    vec4 opColor;
    vec4 baseColor;  
    vec2 point = vec2(uPointX, uPointY);
    
    if (uClear != 0)
        opColor = vec4(0.0, 0.0, 0.0, 1.0);
    else
        opColor = vec4(0.1, 0.0, 0.0, 1.0);
        
    if(uAdd != 0)
        baseColor = texture2D(uSampler0, vTextureCoord);
    else
        opColor = vec4(0.1, 0.0, 0.0, 1.0);
    
    float dist_square = (point.x-vTextureCoord.x*Nx)*(point.x-vTextureCoord.x*Nx)+(point.y-vTextureCoord.y*Ny)*(point.y-vTextureCoord.y*Ny);
    

    
    if (((dist_square < uRadius*uRadius) && (uPointX >= 0.0))==false)
        opColor = baseColor;
        
    // Force drawing to build area
    if(vTextureCoord.x<BL || vTextureCoord.x>BR || vTextureCoord.y>BB || vTextureCoord.y<BT) 
        opColor = vec4(0.0,0.0,0.0,1.0);
        
    gl_FragColor = opColor;
}
</script>
<script id="shader-fs-update-obst-square" type="x-shader/x-fragment">
precision highp float;
precision highp int;

uniform highp sampler2D uSampler0;
uniform float uPointX1, uPointY1, uPointX2, uPointY2;
uniform int uClear;
uniform int uAdd;

varying vec2 vTextureCoord;

void main(void)
{
    vec4 opColor;
    vec4 baseColor;
    
    if(uAdd != 0)
        baseColor = texture2D(uSampler0, vTextureCoord);
    else
        baseColor = vec4(0.0, 0.0, 0.0, 1.0);   
    
    vec2 p1 = vec2(float(uPointX1)/Nx, float(uPointY1)/Ny);
    vec2 p2 = vec2(float(uPointX2)/Nx, float(uPointY2)/Ny);
    
    if (uClear != 0)
        opColor = vec4(0.0, 0.0, 0.0, 1.0);
    else
        opColor = vec4(0.1, 0.0, 0.0, 1.0);
        
    if (uAdd == 0)
        opColor = vec4(0.1, 0.0, 0.0, 1.0);
       
    if(vTextureCoord.x<p1.x || vTextureCoord.x>p2.x || vTextureCoord.y>p1.y || vTextureCoord.y<p2.y)
        gl_FragColor = baseColor;
    else
        gl_FragColor = opColor;
}
</script>
<script id="shader-fs-update-obst-line" type="x-shader/x-fragment">
precision highp float;
precision highp int;

uniform highp sampler2D uSampler0;
uniform float uPointX1, uPointY1, uPointX2, uPointY2, uPointX3, uPointY3, uPointX4, uPointY4;
uniform int uClear;
uniform int uAdd;

varying vec2 vTextureCoord;

void main(void)
{
    vec4 baseColor;

    if(uAdd != 0)
        baseColor = texture2D(uSampler0, vTextureCoord);
    else
        baseColor = vec4(0.0, 0.0, 0.0, 1.0);
        
    vec4 opColor;
    vec2 p1 = vec2(float(uPointX1)/Nx, float(uPointY1)/Ny);
    vec2 p2 = vec2(float(uPointX2)/Nx, float(uPointY2)/Ny);
    vec2 p3 = vec2(float(uPointX3)/Nx, float(uPointY3)/Ny);
    vec2 p4 = vec2(float(uPointX4)/Nx, float(uPointY4)/Ny);
    
    if (uClear != 0)
        opColor = vec4(0.0, 0.0, 0.0, 1.0);
    else
        opColor = vec4(0.1, 0.0, 0.0, 1.0);
        
    if (uAdd == 0)
        opColor = vec4(10.1, 0.0, 0.0, 1.0);
       
    if (triangleArea(p1,p2,vTextureCoord)>0.0 && triangleArea(p2,p3,vTextureCoord)>0.0 && triangleArea(p3,p4,vTextureCoord)>0.0 && triangleArea(p4,p1,vTextureCoord)>0.0)
        gl_FragColor = opColor;
    else
        gl_FragColor = baseColor;
}
</script>
<script id="shader-fs-update-obst-square-copy" type="x-shader/x-fragment">
precision highp float;
precision highp int;

uniform highp sampler2D uSampler0;
uniform float uPointX1, uPointY1, uPointX2, uPointY2;
uniform float uPointX3, uPointY3, uPointX4, uPointY4;
uniform int uClear;
uniform int uAdd;

varying vec2 vTextureCoord;

void main(void)
{
    vec4 opColor;
    vec4 baseColor;
    
    
    if(uAdd != 0)
        baseColor = texture2D(uSampler0, vTextureCoord);
    else
        baseColor = vec4(0.0, 0.0, 0.0, 1.0);   
        
    vec2 p1 = vec2(float(uPointX1)/Nx, float(uPointY1)/Ny);
    vec2 p2 = vec2(float(uPointX2)/Nx, float(uPointY2)/Ny);
    vec2 p3 = vec2(float(uPointX3)/Nx, float(uPointY3)/Ny);
    vec2 p4 = vec2(float(uPointX4)/Nx, float(uPointY4)/Ny);
    
    vec4 offColor = texture2D(uSampler0, vec2(p3.x+(vTextureCoord.x-p1.x),p3.y+(vTextureCoord.y-p1.y)));
    
    
    
    if(vTextureCoord.x<p1.x || vTextureCoord.x>p2.x || vTextureCoord.y>p1.y || vTextureCoord.y<p2.y)
    {
        opColor = baseColor;
        if(uClear != 0) {
            if(vTextureCoord.x<p3.x || vTextureCoord.x>p4.x || vTextureCoord.y>p3.y || vTextureCoord.y<p4.y) {

            } else {
                opColor = vec4(0.0,0.0,0.0,0.0);
            }
        }
    }else{
        opColor = offColor;
    }
        
    gl_FragColor = opColor+baseColor;
}
</script>
<script id="shader-fs-update-display" type="x-shader/x-fragment">
precision highp float;
precision highp int;

uniform highp sampler2D uSampler0, uSampler1, uSampler2;

varying vec2 vTextureCoord;

void main(void)
{
    float ux = color2U(texture2D(uSampler1, vTextureCoord));
    float uy = color2U(texture2D(uSampler2, vTextureCoord));
    
    vec2 offset = vec2(ux, uy);

    gl_FragColor = texture2D(uSampler0, (vTextureCoord.x - offset.x)/Nx, (vTextureCoord.y - offset.y)/Ny);
}
</script>
<script id="shader-fs-init-accum" type="x-shader/x-fragment">
precision highp float;
precision highp int;

uniform int uRhoUxUy;

varying vec2 vTextureCoord;

void main(void)
{
    if (uRhoUxUy == 0)
        gl_FragColor = rho2Color(1.0);
    else if (uRhoUxUy == 1)
        gl_FragColor = u2Color(VEL);
    else
        gl_FragColor = u2Color(0.0);
}
</script>
<script id="shader-fs-init-obst" type="x-shader/x-fragment">
precision highp float;
precision highp int;

varying vec2 vTextureCoord;

void main(void)
{
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
}
</script>
<script id="shader-fs-f-to-accum" type="x-shader/x-fragment">
precision highp float;
precision highp int;

uniform int uRhoUxUy;
uniform highp sampler2D uSampler0, uSampler1, uSampler2, uSampler3, uSampler4, uSampler5, uSampler6, uSampler7, uSampler8;

varying vec2 vTextureCoord;

void main(void)
{
    float f0 = color2Float(texture2D(uSampler0, vTextureCoord));
    float f1 = color2Float(texture2D(uSampler1, vTextureCoord));
    float f2 = color2Float(texture2D(uSampler2, vTextureCoord));
    float f3 = color2Float(texture2D(uSampler3, vTextureCoord));
    float f4 = color2Float(texture2D(uSampler4, vTextureCoord));
    float f5 = color2Float(texture2D(uSampler5, vTextureCoord));
    float f6 = color2Float(texture2D(uSampler6, vTextureCoord));
    float f7 = color2Float(texture2D(uSampler7, vTextureCoord));
    float f8 = color2Float(texture2D(uSampler8, vTextureCoord));
    
    float rho = f0 + f1 + f2 + f3 + f4 + f5 + f6 + f7 + f8;
    
    if (uRhoUxUy == 0)
    {
        gl_FragColor = rho2Color(rho);
    }
    else if (uRhoUxUy == 1)
    {
        float ux = (f1 + f2 + f8 - f4 - f5 - f6) / rho;
        gl_FragColor = u2Color(ux);
    }
    else
    {
        float uy = (f2 + f3 + f4 - f6 - f7 - f8) / rho;
        gl_FragColor = u2Color(uy);
    }
}
</script>
<script id="shader-fs-threshold" type="x-shader/x-fragment">
precision highp float;
precision highp int;

varying vec2 vTextureCoord;

uniform highp sampler2D uSampler0;

void main(void)
{
    float f = color2U(texture2D(uSampler0, vTextureCoord));
    
    float REFERENCE = 0.75;
    float TOL = 0.24;
    if (f < REFERENCE - TOL)
        gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);
    else if (f > REFERENCE + TOL)
        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
    else
        gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);
}
</script>
<script id="shader-fs-show" type="x-shader/x-fragment">
precision highp float;
precision highp int;

varying vec2 vTextureCoord;

uniform highp sampler2D uSampler0;

void main(void)
{
	gl_FragColor = texture2D(uSampler0, vTextureCoord);
}
</script>
<script id="shader-fs-show-umod" type="x-shader/x-fragment">
precision highp float;
precision highp int;

varying vec2 vTextureCoord;

uniform highp sampler2D uSampler0, uSampler1, uSampler2, uSampler3;

uniform int drawIntended;

void main(void)
{
    float ux = color2U(texture2D(uSampler0, vTextureCoord));
    float uy = color2U(texture2D(uSampler1, vTextureCoord));
    float obst = texture2D(uSampler2, vTextureCoord).r;
    float obst_intended = texture2D(uSampler3, vTextureCoord).r;
    float uMod = length(vec2(ux, uy));

    float fourValue = 16.0 * uMod;
    float red   = min(fourValue - 1.5, -fourValue + 4.5);
    float green = min(fourValue - 0.5, -fourValue + 3.5);
    float blue  = min(fourValue + 0.5, -fourValue + 2.5);

    //float red = 1.0-(0.0003/(uMod*uMod*uMod));
    //float blue = 1.0;
    //float green = 1.0;
    
    if(obst>0.0)
    {
        red = 0.6;
        green = 0.05;
        blue = 0.05;
        }
        
    if(drawIntended == 1)
    {
        if(obst_intended>0.0)
        {
            if(obst>0.0)
            {
                red = 0.4;
                green = 0.05;
                blue = 0.05;
            } else {
            red = 1.0-(0.0003/(uMod*uMod*uMod)-obst_intended);
            //red = 1.0-obst_intended;
            blue = 0.2;
            green = 0.2;
            }
        }
    }
    
    
    
	gl_FragColor = vec4(clamp( vec3(red, green, blue), 0.0, 1.0 ) , 1.0);
        
}
</script>
<script id="shader-vs" type="x-shader/x-vertex">
attribute vec3 aVertexPosition;
attribute vec2 aTextureCoord;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4(aVertexPosition, 1.0);
    vTextureCoord = aTextureCoord;
}
</script>
<script id="shader-vs-show" type="x-shader/x-vertex">

uniform lowp mat4 MVPMat;

attribute vec3 aVertexPosition;
attribute vec2 aTextureCoord;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = MVPMat*vec4(aVertexPosition.x*1.0,aVertexPosition.y*1.0,aVertexPosition.z, 1.0);
    vTextureCoord = aTextureCoord;
}
</script>
	<meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
	<meta name="author" content="Bruce Jones" />
	<meta name="keywords" content="lattice boltzmann, lbm, bloodhound, bloodhound ssc, swansea university" />
	<meta name="description" content="Interactive Computational Fluid Dynamics" />

	<title>Fluid simulation with WebGL</title>

	<!-- to correct the unsightly Flash of Unstyled Content. http://www.bluerobot.com/web/css/fouc.asp -->
	<script type="text/javascript" src="lbm_web.js"></script>
	
	<style type="text/css" media="all">
		@import "lbm_web.css";
	</style>
</head>
<body onload="webGLStart();">
    <div id="container">
        <div id="lbm_window">
            <canvas id="main-canvas" style="border: none;" width="1024" height="128">{display: block}</canvas> <br>
        </div>
        <div id="readouts">
            <table id="readouts_table">
                <tr>
                    <td>FPS: <span id="fps">52.68</span></td>
                    <td>Lift: <span id="lift">0.0</span></td>
                    <td>Drag: <span id="drag">0.0</span></td>
                </tr>
            </table>
        </div>
        <div id="simulation_controls">
            <form>
                <input type="radio" name="brush_toggle" id="brush">Brush
                <input type="radio" name="brush_toggle" id="square">Square
                <input type="radio" name="brush_toggle" id="circle">Circle
                <input type="radio" name="brush_toggle" id="line">Line
                <input type="radio" name="brush_toggle" id="select">Select
            </form>
            <form>
                <input type="radio" name="sel_toggle" id="move">Move
                <input type="radio" name="sel_toggle" id="copy">Copy
            </form>
            <div id="slider_brush">
                Smaller <input id="slider_brush" type="range"
                min="1" max="50.0" step="1.0" value="3.0"
                onchange="updateBrushSlider(this.value)"/>Larger
            </div><br/>
            <div id="slider_tau">
                Tau: <input id="slider_tau" type="range"
                min="0.51" max="2.0" step="0.01" value="0.51"
                onchange="updateTauSlider(this.value)"/><span id="slider_tau_val">0.51</span>
            </div><br/>
            
            <div id="slider_u">
                Velocity: <input id="slider_u" type="range"
                min="0.001" max="0.1" step="0.001" value="0.05"
                onchange="updateUSlider(this.value)"/><span id="slider_u_val">0.05</span>
            </div><br/>
            
            <div id="zoom_but">
              <button onclick="zoomClick()">Toggle Zoom</button>
            </div>
            
        </div>
    <div id="disclaimer">
        
    </div>
    </div>


</body></html>